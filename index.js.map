{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///index.js","webpack:///webpack/bootstrap 0d48ec81d4d81adbb12d","webpack:///./jsonFetcher.class.js","webpack:///./~/qs/lib/utils.js","webpack:///./copy.js","webpack:///./merge.js","webpack:///./~/qs/lib/index.js","webpack:///./~/qs/lib/parse.js","webpack:///./~/qs/lib/stringify.js"],"names":["root","factory","exports","module","define","amd","this","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","_classCallCheck","instance","Constructor","TypeError","_createClass","defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","Object","defineProperty","key","protoProps","staticProps","prototype","_typeof","Symbol","iterator","obj","constructor","qs","copy","merge","defaults","credentials","headers","Accept","Content-Type","parseBody","body","JSON","stringify","parseQuery","query","JsonFetcher","config","arguments","undefined","assign","value","url","options","e","Promise","reject","fetch","then","res","json","reduce","method","toUpperCase","request","hexTable","array","Array","toString","arrayToObject","source","plainObjects","create","isArray","push","concat","mergeTarget","keys","acc","hasOwnProperty","decode","str","decodeURIComponent","replace","encode","string","String","out","charCodeAt","charAt","compact","references","refs","lookup","indexOf","compacted","j","isRegExp","isBuffer","newObj","forEach","isObject","item","obj1","obj2","Stringify","Parse","parse","Utils","delimiter","depth","arrayLimit","parameterLimit","strictNullHandling","allowPrototypes","allowDots","decoder","parseValues","parts","split","Infinity","part","pos","slice","val","parseObject","chain","shift","cleanRoot","index","parseInt","isNaN","parseArrays","parseKeys","givenKey","parent","child","segment","exec","opts","tempObj","arrayPrefixGenerators","brackets","prefix","indices","repeat","skipNulls","encoder","object","generateArrayPrefix","filter","sort","Date","toISOString","values","objKeys","arrayFormat","join"],"mappings":"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","file":"./index.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"JsonFetcher\"] = factory();\n\telse\n\t\troot[\"JsonFetcher\"] = factory();\n})(this, function() {\nreturn \n\n\n/** WEBPACK FOOTER **\n ** webpack/universalModuleDefinition\n **/","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"JsonFetcher\"] = factory();\n\telse\n\t\troot[\"JsonFetcher\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol ? \"symbol\" : typeof obj; };\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\t// import { qs } from 'qs';\n\tvar qs = __webpack_require__(4);\n\tvar copy = __webpack_require__(2);\n\tvar merge = __webpack_require__(3);\n\t\n\tvar defaults = {\n\t  credentials: 'same-origin',\n\t  headers: {\n\t    'Accept': 'application/json',\n\t    'Content-Type': 'application/json'\n\t  }\n\t};\n\t\n\tvar parseBody = function parseBody(body) {\n\t  if (!(typeof body === 'undefined' ? 'undefined' : _typeof(body)) === 'string') {\n\t    return body;\n\t  }\n\t  return JSON.stringify(body);\n\t};\n\t\n\tvar parseQuery = function parseQuery(query) {\n\t  if (typeof query === 'string') {\n\t    return query;\n\t  }\n\t  return qs.stringify(query);\n\t};\n\t\n\tvar JsonFetcher = function () {\n\t  function JsonFetcher() {\n\t    var config = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\t\n\t    _classCallCheck(this, JsonFetcher);\n\t\n\t    this.defaults = Object.assign(config, defaults);\n\t  }\n\t\n\t  _createClass(JsonFetcher, [{\n\t    key: 'config',\n\t    value: function config(obj) {\n\t\n\t      // this needs to merge recursively, and it isn't\n\t      merge(this.defaults, obj);\n\t    }\n\t  }, {\n\t    key: 'request',\n\t    value: function request(url) {\n\t      var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n\t\n\t      options = Object.assign(copy(this.defaults), options);\n\t\n\t      if (!!options.body) {\n\t        try {\n\t          options.body = parseBody(options.body);\n\t        } catch (e) {\n\t          return Promise.reject(e);\n\t        }\n\t      }\n\t\n\t      if (options.query) {\n\t        options.query = parseQuery(options.query);\n\t        url += '?' + options.query;\n\t      }\n\t\n\t      return fetch(url, options).then(function (res) {\n\t        return res.json();\n\t      });\n\t    }\n\t  }]);\n\t\n\t  return JsonFetcher;\n\t}();\n\t\n\t['head', 'options', 'connect', 'get', 'post', 'put', 'delete'].reduce(function (prototype, method) {\n\t  prototype[method] = function (url) {\n\t    var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n\t\n\t    options.method = method.toUpperCase();\n\t    return this.request(url, options);\n\t  };\n\t  return prototype;\n\t}, JsonFetcher.prototype);\n\t\n\texports.JsonFetcher = JsonFetcher;\n\n/***/ },\n/* 1 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tvar hexTable = (function () {\n\t    var array = new Array(256);\n\t    for (var i = 0; i < 256; ++i) {\n\t        array[i] = '%' + ((i < 16 ? '0' : '') + i.toString(16)).toUpperCase();\n\t    }\n\t\n\t    return array;\n\t}());\n\t\n\texports.arrayToObject = function (source, options) {\n\t    var obj = options.plainObjects ? Object.create(null) : {};\n\t    for (var i = 0; i < source.length; ++i) {\n\t        if (typeof source[i] !== 'undefined') {\n\t            obj[i] = source[i];\n\t        }\n\t    }\n\t\n\t    return obj;\n\t};\n\t\n\texports.merge = function (target, source, options) {\n\t    if (!source) {\n\t        return target;\n\t    }\n\t\n\t    if (typeof source !== 'object') {\n\t        if (Array.isArray(target)) {\n\t            target.push(source);\n\t        } else if (typeof target === 'object') {\n\t            target[source] = true;\n\t        } else {\n\t            return [target, source];\n\t        }\n\t\n\t        return target;\n\t    }\n\t\n\t    if (typeof target !== 'object') {\n\t        return [target].concat(source);\n\t    }\n\t\n\t    var mergeTarget = target;\n\t    if (Array.isArray(target) && !Array.isArray(source)) {\n\t        mergeTarget = exports.arrayToObject(target, options);\n\t    }\n\t\n\t    return Object.keys(source).reduce(function (acc, key) {\n\t        var value = source[key];\n\t\n\t        if (Object.prototype.hasOwnProperty.call(acc, key)) {\n\t            acc[key] = exports.merge(acc[key], value, options);\n\t        } else {\n\t            acc[key] = value;\n\t        }\n\t        return acc;\n\t    }, mergeTarget);\n\t};\n\t\n\texports.decode = function (str) {\n\t    try {\n\t        return decodeURIComponent(str.replace(/\\+/g, ' '));\n\t    } catch (e) {\n\t        return str;\n\t    }\n\t};\n\t\n\texports.encode = function (str) {\n\t    // This code was originally written by Brian White (mscdex) for the io.js core querystring library.\n\t    // It has been adapted here for stricter adherence to RFC 3986\n\t    if (str.length === 0) {\n\t        return str;\n\t    }\n\t\n\t    var string = typeof str === 'string' ? str : String(str);\n\t\n\t    var out = '';\n\t    for (var i = 0; i < string.length; ++i) {\n\t        var c = string.charCodeAt(i);\n\t\n\t        if (\n\t            c === 0x2D || // -\n\t            c === 0x2E || // .\n\t            c === 0x5F || // _\n\t            c === 0x7E || // ~\n\t            (c >= 0x30 && c <= 0x39) || // 0-9\n\t            (c >= 0x41 && c <= 0x5A) || // a-z\n\t            (c >= 0x61 && c <= 0x7A) // A-Z\n\t        ) {\n\t            out += string.charAt(i);\n\t            continue;\n\t        }\n\t\n\t        if (c < 0x80) {\n\t            out = out + hexTable[c];\n\t            continue;\n\t        }\n\t\n\t        if (c < 0x800) {\n\t            out = out + (hexTable[0xC0 | (c >> 6)] + hexTable[0x80 | (c & 0x3F)]);\n\t            continue;\n\t        }\n\t\n\t        if (c < 0xD800 || c >= 0xE000) {\n\t            out = out + (hexTable[0xE0 | (c >> 12)] + hexTable[0x80 | ((c >> 6) & 0x3F)] + hexTable[0x80 | (c & 0x3F)]);\n\t            continue;\n\t        }\n\t\n\t        i += 1;\n\t        c = 0x10000 + (((c & 0x3FF) << 10) | (string.charCodeAt(i) & 0x3FF));\n\t        out += hexTable[0xF0 | (c >> 18)] + hexTable[0x80 | ((c >> 12) & 0x3F)] + hexTable[0x80 | ((c >> 6) & 0x3F)] + hexTable[0x80 | (c & 0x3F)];\n\t    }\n\t\n\t    return out;\n\t};\n\t\n\texports.compact = function (obj, references) {\n\t    if (typeof obj !== 'object' || obj === null) {\n\t        return obj;\n\t    }\n\t\n\t    var refs = references || [];\n\t    var lookup = refs.indexOf(obj);\n\t    if (lookup !== -1) {\n\t        return refs[lookup];\n\t    }\n\t\n\t    refs.push(obj);\n\t\n\t    if (Array.isArray(obj)) {\n\t        var compacted = [];\n\t\n\t        for (var i = 0; i < obj.length; ++i) {\n\t            if (obj[i] && typeof obj[i] === 'object') {\n\t                compacted.push(exports.compact(obj[i], refs));\n\t            } else if (typeof obj[i] !== 'undefined') {\n\t                compacted.push(obj[i]);\n\t            }\n\t        }\n\t\n\t        return compacted;\n\t    }\n\t\n\t    var keys = Object.keys(obj);\n\t    for (var j = 0; j < keys.length; ++j) {\n\t        var key = keys[j];\n\t        obj[key] = exports.compact(obj[key], refs);\n\t    }\n\t\n\t    return obj;\n\t};\n\t\n\texports.isRegExp = function (obj) {\n\t    return Object.prototype.toString.call(obj) === '[object RegExp]';\n\t};\n\t\n\texports.isBuffer = function (obj) {\n\t    if (obj === null || typeof obj === 'undefined') {\n\t        return false;\n\t    }\n\t\n\t    return !!(obj.constructor && obj.constructor.isBuffer && obj.constructor.isBuffer(obj));\n\t};\n\n\n/***/ },\n/* 2 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t\n\tvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol ? \"symbol\" : typeof obj; };\n\t\n\tvar copy = module.exports = function (obj) {\n\t  if (null == obj || \"object\" != (typeof obj === \"undefined\" ? \"undefined\" : _typeof(obj))) {\n\t    return obj;\n\t  }\n\t\n\t  var newObj = obj.constructor();\n\t\n\t  Object.keys(obj).forEach(function (key) {\n\t    if (obj instanceof Object) {\n\t      newObj[key] = copy(obj[key]);\n\t    } else {\n\t      newObj[key] = obj[key];\n\t    }\n\t  });\n\t  return newObj;\n\t};\n\n/***/ },\n/* 3 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol ? \"symbol\" : typeof obj; };\n\t\n\tfunction isObject(item) {\n\t  return item && (typeof item === 'undefined' ? 'undefined' : _typeof(item)) === 'object' && !Array.isArray(item) && item !== null;\n\t}\n\t\n\tvar merge = module.exports = function (obj1, obj2) {\n\t  if (isObject(obj1) && isObject(obj2)) {\n\t    Object.keys(obj2).forEach(function (key) {\n\t      if (isObject(obj2[key])) {\n\t        if (!obj1[key]) {\n\t          obj1[key] = {};\n\t        }\n\t        merge(obj1[key], obj2[key]);\n\t      } else {\n\t        obj1[key] = obj2[key];\n\t      }\n\t    });\n\t    return obj1;\n\t  } else {\n\t    return obj1;\n\t  }\n\t};\n\n/***/ },\n/* 4 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar Stringify = __webpack_require__(6);\n\tvar Parse = __webpack_require__(5);\n\t\n\tmodule.exports = {\n\t    stringify: Stringify,\n\t    parse: Parse\n\t};\n\n\n/***/ },\n/* 5 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar Utils = __webpack_require__(1);\n\t\n\tvar defaults = {\n\t    delimiter: '&',\n\t    depth: 5,\n\t    arrayLimit: 20,\n\t    parameterLimit: 1000,\n\t    strictNullHandling: false,\n\t    plainObjects: false,\n\t    allowPrototypes: false,\n\t    allowDots: false,\n\t    decoder: Utils.decode\n\t};\n\t\n\tvar parseValues = function parseValues(str, options) {\n\t    var obj = {};\n\t    var parts = str.split(options.delimiter, options.parameterLimit === Infinity ? undefined : options.parameterLimit);\n\t\n\t    for (var i = 0; i < parts.length; ++i) {\n\t        var part = parts[i];\n\t        var pos = part.indexOf(']=') === -1 ? part.indexOf('=') : part.indexOf(']=') + 1;\n\t\n\t        if (pos === -1) {\n\t            obj[options.decoder(part)] = '';\n\t\n\t            if (options.strictNullHandling) {\n\t                obj[options.decoder(part)] = null;\n\t            }\n\t        } else {\n\t            var key = options.decoder(part.slice(0, pos));\n\t            var val = options.decoder(part.slice(pos + 1));\n\t\n\t            if (Object.prototype.hasOwnProperty.call(obj, key)) {\n\t                obj[key] = [].concat(obj[key]).concat(val);\n\t            } else {\n\t                obj[key] = val;\n\t            }\n\t        }\n\t    }\n\t\n\t    return obj;\n\t};\n\t\n\tvar parseObject = function parseObject(chain, val, options) {\n\t    if (!chain.length) {\n\t        return val;\n\t    }\n\t\n\t    var root = chain.shift();\n\t\n\t    var obj;\n\t    if (root === '[]') {\n\t        obj = [];\n\t        obj = obj.concat(parseObject(chain, val, options));\n\t    } else {\n\t        obj = options.plainObjects ? Object.create(null) : {};\n\t        var cleanRoot = root[0] === '[' && root[root.length - 1] === ']' ? root.slice(1, root.length - 1) : root;\n\t        var index = parseInt(cleanRoot, 10);\n\t        if (\n\t            !isNaN(index) &&\n\t            root !== cleanRoot &&\n\t            String(index) === cleanRoot &&\n\t            index >= 0 &&\n\t            (options.parseArrays && index <= options.arrayLimit)\n\t        ) {\n\t            obj = [];\n\t            obj[index] = parseObject(chain, val, options);\n\t        } else {\n\t            obj[cleanRoot] = parseObject(chain, val, options);\n\t        }\n\t    }\n\t\n\t    return obj;\n\t};\n\t\n\tvar parseKeys = function parseKeys(givenKey, val, options) {\n\t    if (!givenKey) {\n\t        return;\n\t    }\n\t\n\t    // Transform dot notation to bracket notation\n\t    var key = options.allowDots ? givenKey.replace(/\\.([^\\.\\[]+)/g, '[$1]') : givenKey;\n\t\n\t    // The regex chunks\n\t\n\t    var parent = /^([^\\[\\]]*)/;\n\t    var child = /(\\[[^\\[\\]]*\\])/g;\n\t\n\t    // Get the parent\n\t\n\t    var segment = parent.exec(key);\n\t\n\t    // Stash the parent if it exists\n\t\n\t    var keys = [];\n\t    if (segment[1]) {\n\t        // If we aren't using plain objects, optionally prefix keys\n\t        // that would overwrite object prototype properties\n\t        if (!options.plainObjects && Object.prototype.hasOwnProperty(segment[1])) {\n\t            if (!options.allowPrototypes) {\n\t                return;\n\t            }\n\t        }\n\t\n\t        keys.push(segment[1]);\n\t    }\n\t\n\t    // Loop through children appending to the array until we hit depth\n\t\n\t    var i = 0;\n\t    while ((segment = child.exec(key)) !== null && i < options.depth) {\n\t        i += 1;\n\t        if (!options.plainObjects && Object.prototype.hasOwnProperty(segment[1].replace(/\\[|\\]/g, ''))) {\n\t            if (!options.allowPrototypes) {\n\t                continue;\n\t            }\n\t        }\n\t        keys.push(segment[1]);\n\t    }\n\t\n\t    // If there's a remainder, just add whatever is left\n\t\n\t    if (segment) {\n\t        keys.push('[' + key.slice(segment.index) + ']');\n\t    }\n\t\n\t    return parseObject(keys, val, options);\n\t};\n\t\n\tmodule.exports = function (str, opts) {\n\t    var options = opts || {};\n\t\n\t    if (options.decoder !== null && options.decoder !== undefined && typeof options.decoder !== 'function') {\n\t        throw new TypeError('Decoder has to be a function.');\n\t    }\n\t\n\t    options.delimiter = typeof options.delimiter === 'string' || Utils.isRegExp(options.delimiter) ? options.delimiter : defaults.delimiter;\n\t    options.depth = typeof options.depth === 'number' ? options.depth : defaults.depth;\n\t    options.arrayLimit = typeof options.arrayLimit === 'number' ? options.arrayLimit : defaults.arrayLimit;\n\t    options.parseArrays = options.parseArrays !== false;\n\t    options.decoder = typeof options.decoder === 'function' ? options.decoder : defaults.decoder;\n\t    options.allowDots = typeof options.allowDots === 'boolean' ? options.allowDots : defaults.allowDots;\n\t    options.plainObjects = typeof options.plainObjects === 'boolean' ? options.plainObjects : defaults.plainObjects;\n\t    options.allowPrototypes = typeof options.allowPrototypes === 'boolean' ? options.allowPrototypes : defaults.allowPrototypes;\n\t    options.parameterLimit = typeof options.parameterLimit === 'number' ? options.parameterLimit : defaults.parameterLimit;\n\t    options.strictNullHandling = typeof options.strictNullHandling === 'boolean' ? options.strictNullHandling : defaults.strictNullHandling;\n\t\n\t    if (str === '' || str === null || typeof str === 'undefined') {\n\t        return options.plainObjects ? Object.create(null) : {};\n\t    }\n\t\n\t    var tempObj = typeof str === 'string' ? parseValues(str, options) : str;\n\t    var obj = options.plainObjects ? Object.create(null) : {};\n\t\n\t    // Iterate over the keys and setup the new object\n\t\n\t    var keys = Object.keys(tempObj);\n\t    for (var i = 0; i < keys.length; ++i) {\n\t        var key = keys[i];\n\t        var newObj = parseKeys(key, tempObj[key], options);\n\t        obj = Utils.merge(obj, newObj, options);\n\t    }\n\t\n\t    return Utils.compact(obj);\n\t};\n\n\n/***/ },\n/* 6 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar Utils = __webpack_require__(1);\n\t\n\tvar arrayPrefixGenerators = {\n\t    brackets: function brackets(prefix) {\n\t        return prefix + '[]';\n\t    },\n\t    indices: function indices(prefix, key) {\n\t        return prefix + '[' + key + ']';\n\t    },\n\t    repeat: function repeat(prefix) {\n\t        return prefix;\n\t    }\n\t};\n\t\n\tvar defaults = {\n\t    delimiter: '&',\n\t    strictNullHandling: false,\n\t    skipNulls: false,\n\t    encode: true,\n\t    encoder: Utils.encode\n\t};\n\t\n\tvar stringify = function stringify(object, prefix, generateArrayPrefix, strictNullHandling, skipNulls, encoder, filter, sort, allowDots) {\n\t    var obj = object;\n\t    if (typeof filter === 'function') {\n\t        obj = filter(prefix, obj);\n\t    } else if (obj instanceof Date) {\n\t        obj = obj.toISOString();\n\t    } else if (obj === null) {\n\t        if (strictNullHandling) {\n\t            return encoder ? encoder(prefix) : prefix;\n\t        }\n\t\n\t        obj = '';\n\t    }\n\t\n\t    if (typeof obj === 'string' || typeof obj === 'number' || typeof obj === 'boolean' || Utils.isBuffer(obj)) {\n\t        if (encoder) {\n\t            return [encoder(prefix) + '=' + encoder(obj)];\n\t        }\n\t        return [prefix + '=' + String(obj)];\n\t    }\n\t\n\t    var values = [];\n\t\n\t    if (typeof obj === 'undefined') {\n\t        return values;\n\t    }\n\t\n\t    var objKeys;\n\t    if (Array.isArray(filter)) {\n\t        objKeys = filter;\n\t    } else {\n\t        var keys = Object.keys(obj);\n\t        objKeys = sort ? keys.sort(sort) : keys;\n\t    }\n\t\n\t    for (var i = 0; i < objKeys.length; ++i) {\n\t        var key = objKeys[i];\n\t\n\t        if (skipNulls && obj[key] === null) {\n\t            continue;\n\t        }\n\t\n\t        if (Array.isArray(obj)) {\n\t            values = values.concat(stringify(obj[key], generateArrayPrefix(prefix, key), generateArrayPrefix, strictNullHandling, skipNulls, encoder, filter, sort, allowDots));\n\t        } else {\n\t            values = values.concat(stringify(obj[key], prefix + (allowDots ? '.' + key : '[' + key + ']'), generateArrayPrefix, strictNullHandling, skipNulls, encoder, filter, sort, allowDots));\n\t        }\n\t    }\n\t\n\t    return values;\n\t};\n\t\n\tmodule.exports = function (object, opts) {\n\t    var obj = object;\n\t    var options = opts || {};\n\t    var delimiter = typeof options.delimiter === 'undefined' ? defaults.delimiter : options.delimiter;\n\t    var strictNullHandling = typeof options.strictNullHandling === 'boolean' ? options.strictNullHandling : defaults.strictNullHandling;\n\t    var skipNulls = typeof options.skipNulls === 'boolean' ? options.skipNulls : defaults.skipNulls;\n\t    var encode = typeof options.encode === 'boolean' ? options.encode : defaults.encode;\n\t    var encoder = encode ? (typeof options.encoder === 'function' ? options.encoder : defaults.encoder) : null;\n\t    var sort = typeof options.sort === 'function' ? options.sort : null;\n\t    var allowDots = typeof options.allowDots === 'undefined' ? false : options.allowDots;\n\t    var objKeys;\n\t    var filter;\n\t\n\t    if (options.encoder !== null && options.encoder !== undefined && typeof options.encoder !== 'function') {\n\t        throw new TypeError('Encoder has to be a function.');\n\t    }\n\t\n\t    if (typeof options.filter === 'function') {\n\t        filter = options.filter;\n\t        obj = filter('', obj);\n\t    } else if (Array.isArray(options.filter)) {\n\t        objKeys = filter = options.filter;\n\t    }\n\t\n\t    var keys = [];\n\t\n\t    if (typeof obj !== 'object' || obj === null) {\n\t        return '';\n\t    }\n\t\n\t    var arrayFormat;\n\t    if (options.arrayFormat in arrayPrefixGenerators) {\n\t        arrayFormat = options.arrayFormat;\n\t    } else if ('indices' in options) {\n\t        arrayFormat = options.indices ? 'indices' : 'repeat';\n\t    } else {\n\t        arrayFormat = 'indices';\n\t    }\n\t\n\t    var generateArrayPrefix = arrayPrefixGenerators[arrayFormat];\n\t\n\t    if (!objKeys) {\n\t        objKeys = Object.keys(obj);\n\t    }\n\t\n\t    if (sort) {\n\t        objKeys.sort(sort);\n\t    }\n\t\n\t    for (var i = 0; i < objKeys.length; ++i) {\n\t        var key = objKeys[i];\n\t\n\t        if (skipNulls && obj[key] === null) {\n\t            continue;\n\t        }\n\t\n\t        keys = keys.concat(stringify(obj[key], key, generateArrayPrefix, strictNullHandling, skipNulls, encoder, filter, sort, allowDots));\n\t    }\n\t\n\t    return keys.join(delimiter);\n\t};\n\n\n/***/ }\n/******/ ])\n});\n;\n\n\n/** WEBPACK FOOTER **\n ** index.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 0d48ec81d4d81adbb12d\n **/","// import { qs } from 'qs';\nconst qs = require('qs');\nconst copy = require('./copy');\nconst merge = require('./merge')\n\nconst defaults = {\n  credentials: 'same-origin',\n  headers: {\n    'Accept': 'application/json',\n    'Content-Type': 'application/json'\n  }\n};\n\nconst parseBody = body => {\n  if(!typeof body === 'string') {\n    return body;\n  }\n  return JSON.stringify(body);\n}\n\nconst parseQuery = query => {\n  if(typeof query === 'string') {\n    return query;\n  }\n  return qs.stringify(query);\n}\n\nclass JsonFetcher {\n  constructor(config={}) {\n    this.defaults = Object.assign(config, defaults);\n  }\n\n  config(obj) {\n\n    // this needs to merge recursively, and it isn't\n    merge(this.defaults, obj);\n  }\n\n  request(url, options={}) {\n    options = Object.assign(copy(this.defaults), options);\n\n    if(!!options.body) {\n      try {\n        options.body = parseBody(options.body);\n      } catch (e) {\n        return Promise.reject(e);\n      }\n    }\n\n    if(options.query) {\n      options.query = parseQuery(options.query);\n      url += '?' + options.query;\n    }\n\n    return fetch(url,options)\n      .then(res => res.json());\n  }\n}\n\n['head', 'options', 'connect', 'get', 'post', 'put', 'delete']\n.reduce(function(prototype, method) {\n  prototype[method] = function(url, options={}) {\n    options.method = method.toUpperCase();\n    return this.request(url, options);\n  }\n  return prototype;\n}, JsonFetcher.prototype);\n\nexports.JsonFetcher = JsonFetcher;\n\n\n/** WEBPACK FOOTER **\n ** ./jsonFetcher.class.js\n **/","'use strict';\n\nvar hexTable = (function () {\n    var array = new Array(256);\n    for (var i = 0; i < 256; ++i) {\n        array[i] = '%' + ((i < 16 ? '0' : '') + i.toString(16)).toUpperCase();\n    }\n\n    return array;\n}());\n\nexports.arrayToObject = function (source, options) {\n    var obj = options.plainObjects ? Object.create(null) : {};\n    for (var i = 0; i < source.length; ++i) {\n        if (typeof source[i] !== 'undefined') {\n            obj[i] = source[i];\n        }\n    }\n\n    return obj;\n};\n\nexports.merge = function (target, source, options) {\n    if (!source) {\n        return target;\n    }\n\n    if (typeof source !== 'object') {\n        if (Array.isArray(target)) {\n            target.push(source);\n        } else if (typeof target === 'object') {\n            target[source] = true;\n        } else {\n            return [target, source];\n        }\n\n        return target;\n    }\n\n    if (typeof target !== 'object') {\n        return [target].concat(source);\n    }\n\n    var mergeTarget = target;\n    if (Array.isArray(target) && !Array.isArray(source)) {\n        mergeTarget = exports.arrayToObject(target, options);\n    }\n\n    return Object.keys(source).reduce(function (acc, key) {\n        var value = source[key];\n\n        if (Object.prototype.hasOwnProperty.call(acc, key)) {\n            acc[key] = exports.merge(acc[key], value, options);\n        } else {\n            acc[key] = value;\n        }\n        return acc;\n    }, mergeTarget);\n};\n\nexports.decode = function (str) {\n    try {\n        return decodeURIComponent(str.replace(/\\+/g, ' '));\n    } catch (e) {\n        return str;\n    }\n};\n\nexports.encode = function (str) {\n    // This code was originally written by Brian White (mscdex) for the io.js core querystring library.\n    // It has been adapted here for stricter adherence to RFC 3986\n    if (str.length === 0) {\n        return str;\n    }\n\n    var string = typeof str === 'string' ? str : String(str);\n\n    var out = '';\n    for (var i = 0; i < string.length; ++i) {\n        var c = string.charCodeAt(i);\n\n        if (\n            c === 0x2D || // -\n            c === 0x2E || // .\n            c === 0x5F || // _\n            c === 0x7E || // ~\n            (c >= 0x30 && c <= 0x39) || // 0-9\n            (c >= 0x41 && c <= 0x5A) || // a-z\n            (c >= 0x61 && c <= 0x7A) // A-Z\n        ) {\n            out += string.charAt(i);\n            continue;\n        }\n\n        if (c < 0x80) {\n            out = out + hexTable[c];\n            continue;\n        }\n\n        if (c < 0x800) {\n            out = out + (hexTable[0xC0 | (c >> 6)] + hexTable[0x80 | (c & 0x3F)]);\n            continue;\n        }\n\n        if (c < 0xD800 || c >= 0xE000) {\n            out = out + (hexTable[0xE0 | (c >> 12)] + hexTable[0x80 | ((c >> 6) & 0x3F)] + hexTable[0x80 | (c & 0x3F)]);\n            continue;\n        }\n\n        i += 1;\n        c = 0x10000 + (((c & 0x3FF) << 10) | (string.charCodeAt(i) & 0x3FF));\n        out += hexTable[0xF0 | (c >> 18)] + hexTable[0x80 | ((c >> 12) & 0x3F)] + hexTable[0x80 | ((c >> 6) & 0x3F)] + hexTable[0x80 | (c & 0x3F)];\n    }\n\n    return out;\n};\n\nexports.compact = function (obj, references) {\n    if (typeof obj !== 'object' || obj === null) {\n        return obj;\n    }\n\n    var refs = references || [];\n    var lookup = refs.indexOf(obj);\n    if (lookup !== -1) {\n        return refs[lookup];\n    }\n\n    refs.push(obj);\n\n    if (Array.isArray(obj)) {\n        var compacted = [];\n\n        for (var i = 0; i < obj.length; ++i) {\n            if (obj[i] && typeof obj[i] === 'object') {\n                compacted.push(exports.compact(obj[i], refs));\n            } else if (typeof obj[i] !== 'undefined') {\n                compacted.push(obj[i]);\n            }\n        }\n\n        return compacted;\n    }\n\n    var keys = Object.keys(obj);\n    for (var j = 0; j < keys.length; ++j) {\n        var key = keys[j];\n        obj[key] = exports.compact(obj[key], refs);\n    }\n\n    return obj;\n};\n\nexports.isRegExp = function (obj) {\n    return Object.prototype.toString.call(obj) === '[object RegExp]';\n};\n\nexports.isBuffer = function (obj) {\n    if (obj === null || typeof obj === 'undefined') {\n        return false;\n    }\n\n    return !!(obj.constructor && obj.constructor.isBuffer && obj.constructor.isBuffer(obj));\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/qs/lib/utils.js\n ** module id = 1\n ** module chunks = 0\n **/","const copy = module.exports = obj => {\n  if (null == obj || \"object\" != typeof obj) { return obj; }\n\n  const newObj = obj.constructor();\n\n  Object.keys(obj).forEach(key => {\n    if(obj instanceof Object) {\n      newObj[key] = copy(obj[key]);\n    } else {\n      newObj[key] = obj[key];\n    }\n  });\n  return newObj;\n}\n\n\n\n\n/** WEBPACK FOOTER **\n ** ./copy.js\n **/","function isObject(item) {\n  return (item && typeof item === 'object' && !Array.isArray(item) && item !== null);\n}\n\nconst merge = module.exports = (obj1, obj2) => {\n  if(isObject(obj1) && isObject(obj2)) {\n    Object.keys(obj2)\n      .forEach(key => {\n        if(isObject(obj2[key])) {\n          if(!obj1[key]) {\n            obj1[key] = {};\n          }\n          merge(obj1[key], obj2[key]);\n        } else {\n          obj1[key] = obj2[key];          \n        }\n      });\n      return obj1;\n  } else {\n    return obj1;\n  }\n}\n\n\n/** WEBPACK FOOTER **\n ** ./merge.js\n **/","'use strict';\n\nvar Stringify = require('./stringify');\nvar Parse = require('./parse');\n\nmodule.exports = {\n    stringify: Stringify,\n    parse: Parse\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/qs/lib/index.js\n ** module id = 4\n ** module chunks = 0\n **/","'use strict';\n\nvar Utils = require('./utils');\n\nvar defaults = {\n    delimiter: '&',\n    depth: 5,\n    arrayLimit: 20,\n    parameterLimit: 1000,\n    strictNullHandling: false,\n    plainObjects: false,\n    allowPrototypes: false,\n    allowDots: false,\n    decoder: Utils.decode\n};\n\nvar parseValues = function parseValues(str, options) {\n    var obj = {};\n    var parts = str.split(options.delimiter, options.parameterLimit === Infinity ? undefined : options.parameterLimit);\n\n    for (var i = 0; i < parts.length; ++i) {\n        var part = parts[i];\n        var pos = part.indexOf(']=') === -1 ? part.indexOf('=') : part.indexOf(']=') + 1;\n\n        if (pos === -1) {\n            obj[options.decoder(part)] = '';\n\n            if (options.strictNullHandling) {\n                obj[options.decoder(part)] = null;\n            }\n        } else {\n            var key = options.decoder(part.slice(0, pos));\n            var val = options.decoder(part.slice(pos + 1));\n\n            if (Object.prototype.hasOwnProperty.call(obj, key)) {\n                obj[key] = [].concat(obj[key]).concat(val);\n            } else {\n                obj[key] = val;\n            }\n        }\n    }\n\n    return obj;\n};\n\nvar parseObject = function parseObject(chain, val, options) {\n    if (!chain.length) {\n        return val;\n    }\n\n    var root = chain.shift();\n\n    var obj;\n    if (root === '[]') {\n        obj = [];\n        obj = obj.concat(parseObject(chain, val, options));\n    } else {\n        obj = options.plainObjects ? Object.create(null) : {};\n        var cleanRoot = root[0] === '[' && root[root.length - 1] === ']' ? root.slice(1, root.length - 1) : root;\n        var index = parseInt(cleanRoot, 10);\n        if (\n            !isNaN(index) &&\n            root !== cleanRoot &&\n            String(index) === cleanRoot &&\n            index >= 0 &&\n            (options.parseArrays && index <= options.arrayLimit)\n        ) {\n            obj = [];\n            obj[index] = parseObject(chain, val, options);\n        } else {\n            obj[cleanRoot] = parseObject(chain, val, options);\n        }\n    }\n\n    return obj;\n};\n\nvar parseKeys = function parseKeys(givenKey, val, options) {\n    if (!givenKey) {\n        return;\n    }\n\n    // Transform dot notation to bracket notation\n    var key = options.allowDots ? givenKey.replace(/\\.([^\\.\\[]+)/g, '[$1]') : givenKey;\n\n    // The regex chunks\n\n    var parent = /^([^\\[\\]]*)/;\n    var child = /(\\[[^\\[\\]]*\\])/g;\n\n    // Get the parent\n\n    var segment = parent.exec(key);\n\n    // Stash the parent if it exists\n\n    var keys = [];\n    if (segment[1]) {\n        // If we aren't using plain objects, optionally prefix keys\n        // that would overwrite object prototype properties\n        if (!options.plainObjects && Object.prototype.hasOwnProperty(segment[1])) {\n            if (!options.allowPrototypes) {\n                return;\n            }\n        }\n\n        keys.push(segment[1]);\n    }\n\n    // Loop through children appending to the array until we hit depth\n\n    var i = 0;\n    while ((segment = child.exec(key)) !== null && i < options.depth) {\n        i += 1;\n        if (!options.plainObjects && Object.prototype.hasOwnProperty(segment[1].replace(/\\[|\\]/g, ''))) {\n            if (!options.allowPrototypes) {\n                continue;\n            }\n        }\n        keys.push(segment[1]);\n    }\n\n    // If there's a remainder, just add whatever is left\n\n    if (segment) {\n        keys.push('[' + key.slice(segment.index) + ']');\n    }\n\n    return parseObject(keys, val, options);\n};\n\nmodule.exports = function (str, opts) {\n    var options = opts || {};\n\n    if (options.decoder !== null && options.decoder !== undefined && typeof options.decoder !== 'function') {\n        throw new TypeError('Decoder has to be a function.');\n    }\n\n    options.delimiter = typeof options.delimiter === 'string' || Utils.isRegExp(options.delimiter) ? options.delimiter : defaults.delimiter;\n    options.depth = typeof options.depth === 'number' ? options.depth : defaults.depth;\n    options.arrayLimit = typeof options.arrayLimit === 'number' ? options.arrayLimit : defaults.arrayLimit;\n    options.parseArrays = options.parseArrays !== false;\n    options.decoder = typeof options.decoder === 'function' ? options.decoder : defaults.decoder;\n    options.allowDots = typeof options.allowDots === 'boolean' ? options.allowDots : defaults.allowDots;\n    options.plainObjects = typeof options.plainObjects === 'boolean' ? options.plainObjects : defaults.plainObjects;\n    options.allowPrototypes = typeof options.allowPrototypes === 'boolean' ? options.allowPrototypes : defaults.allowPrototypes;\n    options.parameterLimit = typeof options.parameterLimit === 'number' ? options.parameterLimit : defaults.parameterLimit;\n    options.strictNullHandling = typeof options.strictNullHandling === 'boolean' ? options.strictNullHandling : defaults.strictNullHandling;\n\n    if (str === '' || str === null || typeof str === 'undefined') {\n        return options.plainObjects ? Object.create(null) : {};\n    }\n\n    var tempObj = typeof str === 'string' ? parseValues(str, options) : str;\n    var obj = options.plainObjects ? Object.create(null) : {};\n\n    // Iterate over the keys and setup the new object\n\n    var keys = Object.keys(tempObj);\n    for (var i = 0; i < keys.length; ++i) {\n        var key = keys[i];\n        var newObj = parseKeys(key, tempObj[key], options);\n        obj = Utils.merge(obj, newObj, options);\n    }\n\n    return Utils.compact(obj);\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/qs/lib/parse.js\n ** module id = 5\n ** module chunks = 0\n **/","'use strict';\n\nvar Utils = require('./utils');\n\nvar arrayPrefixGenerators = {\n    brackets: function brackets(prefix) {\n        return prefix + '[]';\n    },\n    indices: function indices(prefix, key) {\n        return prefix + '[' + key + ']';\n    },\n    repeat: function repeat(prefix) {\n        return prefix;\n    }\n};\n\nvar defaults = {\n    delimiter: '&',\n    strictNullHandling: false,\n    skipNulls: false,\n    encode: true,\n    encoder: Utils.encode\n};\n\nvar stringify = function stringify(object, prefix, generateArrayPrefix, strictNullHandling, skipNulls, encoder, filter, sort, allowDots) {\n    var obj = object;\n    if (typeof filter === 'function') {\n        obj = filter(prefix, obj);\n    } else if (obj instanceof Date) {\n        obj = obj.toISOString();\n    } else if (obj === null) {\n        if (strictNullHandling) {\n            return encoder ? encoder(prefix) : prefix;\n        }\n\n        obj = '';\n    }\n\n    if (typeof obj === 'string' || typeof obj === 'number' || typeof obj === 'boolean' || Utils.isBuffer(obj)) {\n        if (encoder) {\n            return [encoder(prefix) + '=' + encoder(obj)];\n        }\n        return [prefix + '=' + String(obj)];\n    }\n\n    var values = [];\n\n    if (typeof obj === 'undefined') {\n        return values;\n    }\n\n    var objKeys;\n    if (Array.isArray(filter)) {\n        objKeys = filter;\n    } else {\n        var keys = Object.keys(obj);\n        objKeys = sort ? keys.sort(sort) : keys;\n    }\n\n    for (var i = 0; i < objKeys.length; ++i) {\n        var key = objKeys[i];\n\n        if (skipNulls && obj[key] === null) {\n            continue;\n        }\n\n        if (Array.isArray(obj)) {\n            values = values.concat(stringify(obj[key], generateArrayPrefix(prefix, key), generateArrayPrefix, strictNullHandling, skipNulls, encoder, filter, sort, allowDots));\n        } else {\n            values = values.concat(stringify(obj[key], prefix + (allowDots ? '.' + key : '[' + key + ']'), generateArrayPrefix, strictNullHandling, skipNulls, encoder, filter, sort, allowDots));\n        }\n    }\n\n    return values;\n};\n\nmodule.exports = function (object, opts) {\n    var obj = object;\n    var options = opts || {};\n    var delimiter = typeof options.delimiter === 'undefined' ? defaults.delimiter : options.delimiter;\n    var strictNullHandling = typeof options.strictNullHandling === 'boolean' ? options.strictNullHandling : defaults.strictNullHandling;\n    var skipNulls = typeof options.skipNulls === 'boolean' ? options.skipNulls : defaults.skipNulls;\n    var encode = typeof options.encode === 'boolean' ? options.encode : defaults.encode;\n    var encoder = encode ? (typeof options.encoder === 'function' ? options.encoder : defaults.encoder) : null;\n    var sort = typeof options.sort === 'function' ? options.sort : null;\n    var allowDots = typeof options.allowDots === 'undefined' ? false : options.allowDots;\n    var objKeys;\n    var filter;\n\n    if (options.encoder !== null && options.encoder !== undefined && typeof options.encoder !== 'function') {\n        throw new TypeError('Encoder has to be a function.');\n    }\n\n    if (typeof options.filter === 'function') {\n        filter = options.filter;\n        obj = filter('', obj);\n    } else if (Array.isArray(options.filter)) {\n        objKeys = filter = options.filter;\n    }\n\n    var keys = [];\n\n    if (typeof obj !== 'object' || obj === null) {\n        return '';\n    }\n\n    var arrayFormat;\n    if (options.arrayFormat in arrayPrefixGenerators) {\n        arrayFormat = options.arrayFormat;\n    } else if ('indices' in options) {\n        arrayFormat = options.indices ? 'indices' : 'repeat';\n    } else {\n        arrayFormat = 'indices';\n    }\n\n    var generateArrayPrefix = arrayPrefixGenerators[arrayFormat];\n\n    if (!objKeys) {\n        objKeys = Object.keys(obj);\n    }\n\n    if (sort) {\n        objKeys.sort(sort);\n    }\n\n    for (var i = 0; i < objKeys.length; ++i) {\n        var key = objKeys[i];\n\n        if (skipNulls && obj[key] === null) {\n            continue;\n        }\n\n        keys = keys.concat(stringify(obj[key], key, generateArrayPrefix, strictNullHandling, skipNulls, encoder, filter, sort, allowDots));\n    }\n\n    return keys.join(delimiter);\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/qs/lib/stringify.js\n ** module id = 6\n ** module chunks = 0\n **/"],"sourceRoot":""}